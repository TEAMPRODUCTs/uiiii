<!DOCTYPE html>

<html>
    <head>
     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
   </head>
   <body>
   	<div>
   		<a>click me1</a>
   		<a>click me2</a>
   		<a>click me3</a>
   		<a>click me4</a>
   	</div>
   </body>
   <script type="text/javascript">

   // 这个代码是错误的，因为变量i从来就没背locked住
	// 相反，当循环执行以后，我们在点击的时候i才获得数值
	// 因为这个时候i操真正获得值
	// 所以说无论点击那个连接，最终显示的都是I am link #100（如果有10个a元素的话）
   function func1(){
   	var aElem = document.getElementsByTagName("a");
   	for (var i = aElem.length - 1; i >= 0; i--) {
   		aElem[i].addEventListener("click",function(e){
   			e.preventDefault();
   			alert("I'm click #" + i);
   		},false);
   	};

   	i= 100;//
   }

   func1();

// 这个是可以用的，因为他在自执行函数表达式闭包内部
// i的值作为locked的索引存在，在循环执行结束以后，尽管最后i的值变成了a元素总数（例如10）
// 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了
// 所以当点击连接的时候，结果是正确的
   function func2(){
   		var aElem = document.getElementsByTagName("a");
   		for (var i = aElem.length - 1; i >= 0; i--) {
   			(function(lockIndex){
					aElem[lockIndex].addEventListener("click",function(e){
			   			e.preventDefault();
			   			alert("I'm click #" + lockIndex);
			   		},false);
	   		})(i);
   		}
   		i = 300;
   }

   func2();

   // 你也可以像下面这样应用，在处理函数那里使用自执行函数表达式
// 而不是在addEventListener外部
// 但是相对来说，上面的代码更具可读性
   function func3() {
   		var aElem = document.getElementsByTagName("a");
   		for (var i = aElem.length - 1; i >= 0; i--) {
   			aElem[i].addEventListener("click",(function(lockIndex){
   				return function(e){
   					e.preventDefault();
			    	alert("I'm click func3#" + lockIndex);
   				}
   			})(i), false)
   		}
   }
   func3();

   </script>
</html>